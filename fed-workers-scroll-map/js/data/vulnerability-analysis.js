// vulnerability-analysis.js - Functions for vulnerability calculations and analysis
import { normalize, inverseNormalize } from "../utils/normalization.js";

/**
 * Define safe property accessor with multiple fallback properties
 * @param {Object} county - County data object
 * @param {Array<string>} propNames - Primary property names to check
 * @param {Array<string>} alternateNames - Alternative property names to check
 * @returns {number|null} Property value or null if not found
 */
function getPropertySafe(county, propNames, alternateNames = []) {
  // Try the primary property names
  for (const name of propNames) {
    const value = county.properties[name];
    if (value !== undefined && value !== null) {
      const numValue = typeof value === "string" ? parseFloat(value) : value;
      if (!isNaN(numValue)) return numValue;
    }
  }

  // If not found, try alternate property names
  for (const name of alternateNames) {
    const value = county.properties[name];
    if (value !== undefined && value !== null) {
      const numValue = typeof value === "string" ? parseFloat(value) : value;
      if (!isNaN(numValue)) return numValue;
    }
  }

  return null;
}

/**
 * Calculate vulnerability index for counties
 * @param {Array} counties - Array of county data objects
 * @returns {Array} Counties with calculated vulnerability indices
 */
export function calculateVulnerabilityIndex(counties) {
  // Check if counties array exists and has elements
  if (!counties || counties.length === 0) {
    console.error("No counties data available");
    return counties;
  }

  // Filter counties with valid data for all factors
  const validCounties = counties.filter((county) => {
    // Try multiple property name variations for each metric
    const pctFederal = getPropertySafe(
      county,
      ["pct_federal"],
      ["fedDependency", "fed_dependency", "federal_pct", "fedWorkersPct"]
    );

    const unemploymentRate = getPropertySafe(
      county,
      ["unemployment_rate"],
      ["unemploymentRate", "unemp_rate", "unemployment"]
    );

    const medianIncome = getPropertySafe(
      county,
      ["median_income"],
      ["medianIncome", "median_household_income", "income"]
    );

    return (
      pctFederal !== null && unemploymentRate !== null && medianIncome !== null
    );
  });

  console.log(
    `Found ${validCounties.length} counties with valid data for vulnerability calculation`
  );

  if (validCounties.length === 0) {
    console.error("No counties with valid data for vulnerability calculation!");
    return counties;
  }

  // Calculate min/max values for normalization
  const minMax = {
    pct_federal: {
      min: Math.min(
        ...validCounties.map((c) =>
          getPropertySafe(
            c,
            ["pct_federal"],
            ["fedDependency", "fed_dependency"]
          )
        )
      ),
      max: Math.max(
        ...validCounties.map((c) =>
          getPropertySafe(
            c,
            ["pct_federal"],
            ["fedDependency", "fed_dependency"]
          )
        )
      ),
    },
    unemployment_rate: {
      min: Math.min(
        ...validCounties.map((c) =>
          getPropertySafe(c, ["unemployment_rate"], ["unemploymentRate"])
        )
      ),
      max: Math.max(
        ...validCounties.map((c) =>
          getPropertySafe(c, ["unemployment_rate"], ["unemploymentRate"])
        )
      ),
    },
    median_income: {
      min: Math.min(
        ...validCounties.map((c) =>
          getPropertySafe(c, ["median_income"], ["medianIncome"])
        )
      ),
      max: Math.max(
        ...validCounties.map((c) =>
          getPropertySafe(c, ["median_income"], ["medianIncome"])
        )
      ),
    },
  };

  // Apply the vulnerability calculation to each county
  let calculatedCount = 0;

  counties.forEach((county) => {
    const props = county.properties;

    // Get values using safe access with fallbacks
    const pctFederal = getPropertySafe(
      county,
      ["pct_federal"],
      ["fedDependency", "fed_dependency", "federal_pct"]
    );

    const unemploymentRate = getPropertySafe(
      county,
      ["unemployment_rate"],
      ["unemploymentRate", "unemp_rate"]
    );

    const medianIncome = getPropertySafe(
      county,
      ["median_income"],
      ["medianIncome", "income"]
    );

    // Skip counties with invalid data
    if (
      pctFederal === null ||
      unemploymentRate === null ||
      medianIncome === null
    ) {
      props.vulnerabilityIndex = null;
      props.category = "No Data";
      return;
    }

    // Component 1: Federal dependency (higher % = higher vulnerability)
    const fedDependencyScore = normalize(
      pctFederal,
      minMax.pct_federal.min,
      minMax.pct_federal.max
    );

    // Component 2: Unemployment vulnerability (higher unemployment = higher vulnerability)
    const unemploymentScore = normalize(
      unemploymentRate,
      minMax.unemployment_rate.min,
      minMax.unemployment_rate.max
    );

    // Component 3: Income vulnerability (lower income = higher vulnerability)
    const incomeScore = inverseNormalize(
      medianIncome,
      minMax.median_income.min,
      minMax.median_income.max
    );

    // Calculate weighted vulnerability score (0-100 scale)
    props.vulnerabilityIndex = Number(
      (
        (0.5 * fedDependencyScore +
          0.3 * unemploymentScore +
          0.2 * incomeScore) *
        100
      ).toFixed(2)
    );

    // Store component scores for tooltips
    props.fed_dependency = Number((fedDependencyScore * 100).toFixed(2));
    props.unemployment_vulnerability = Number(
      (unemploymentScore * 100).toFixed(2)
    );
    props.income_vulnerability = Number((incomeScore * 100).toFixed(2));

    // Assign vulnerability category
    props.category = assignVulnerabilityCategory(props.vulnerabilityIndex);
    calculatedCount++;
  });

  console.log(`Vulnerability index calculated for ${calculatedCount} counties`);
  return counties;
}

/**
 * Assign vulnerability category based on index value
 * @param {number} index - Vulnerability index
 * @returns {string} Vulnerability category
 */
export function assignVulnerabilityCategory(index) {
  if (index === null || index === undefined) return "No Data";

  if (index < 17.8) return "Very Low";
  if (index < 20.0) return "Low";
  if (index < 26.2) return "Moderate";
  if (index < 30.1) return "High";
  return "Very High";
}

/**
 * Assign vulnerability categories based on dynamic Jenks breaks
 * @param {number} index - Vulnerability index
 * @param {Array<number>} jenksBreaks - Array of break points
 * @returns {string} Vulnerability category
 */
export function assignVulnerabilityCategoryDynamic(index, jenksBreaks) {
  if (index === null || index === undefined) return "No Data";

  // Sort breaks in ascending order
  const breaks = jenksBreaks.slice().sort((a, b) => a - b);

  if (index < breaks[0]) return "Very Low";
  if (index < breaks[1]) return "Low";
  if (index < breaks[2]) return "Moderate";
  if (index < breaks[3]) return "High";
  return "Very High";
}

/**
 * Identify counties that are vulnerable to federal job cuts
 * @param {Array} counties - Array of county data objects
 * @param {Object} thresholds - Threshold configuration
 * @returns {Array<string>} Array of vulnerable county IDs
 */
export function identifyVulnerableCounties(counties, thresholds) {
  if (!counties) return [];

  console.log("Identifying vulnerable counties...");

  // Use the threshold values from config
  const fedThreshold = thresholds.highFederalThreshold || 5000;
  const vulnThreshold = thresholds.highVulnerabilityThreshold || 40;

  // Filter counties that meet both criteria
  const vulnerableCounties = counties.filter((county) => {
    const fedWorkers = county.properties.fed_workers_per_100k || 0;
    const vulnerabilityScore = county.properties.vulnerabilityIndex || 0;

    return fedWorkers >= fedThreshold && vulnerabilityScore >= vulnThreshold;
  });

  console.log(`Found ${vulnerableCounties.length} vulnerable counties`);

  // Add a flag to these counties' properties
  vulnerableCounties.forEach((county) => {
    county.properties.isVulnerable = true;
  });

  // Return county ids for easy lookup
  return vulnerableCounties.map((county) => county.id);
}

/**
 * Update vulnerability categories based on calculated Jenks breaks
 * @param {Array} counties - Array of county data objects
 * @param {Array<number>} jenksBreaks - Jenks natural breaks
 */
export function updateVulnerabilityCategories(counties, jenksBreaks) {
  console.log("Updating vulnerability categories based on Jenks breaks...");

  if (!jenksBreaks || jenksBreaks.length < 4) {
    console.warn("Insufficient breaks to update categories");
    return;
  }

  // Log the breaks we'll use for category assignment
  console.log("Using Jenks breaks for vulnerability categories:", jenksBreaks);

  // Update each county's category based on the Jenks breaks
  let categoryCounts = {
    "Very Low": 0,
    Low: 0,
    Moderate: 0,
    High: 0,
    "Very High": 0,
    "No Data": 0,
  };

  counties.forEach((county) => {
    if (county.properties.vulnerabilityIndex !== null) {
      county.properties.category = assignVulnerabilityCategoryDynamic(
        county.properties.vulnerabilityIndex,
        jenksBreaks
      );
      categoryCounts[county.properties.category]++;
    } else {
      county.properties.category = "No Data";
      categoryCounts["No Data"]++;
    }
  });

  console.log("Updated vulnerability categories distribution:", categoryCounts);
}
